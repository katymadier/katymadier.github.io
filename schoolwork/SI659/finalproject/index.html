<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>A-Frame XR Test</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script src='js/aframe-master.js'></script>
  <script src='js/three.xr.js'></script>
  <script src='js/aframe-xr.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.13.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@0.2.3"></script>
  <script>
    //from A-Frame
    AFRAME.registerComponent('collider-check', {
      dependencies: ['raycaster'],

      init: function() {
        this.el.addEventListener('raycaster-intersection', function() {
          console.log('Player hit something!');
        });
      }
    });
  </script>
  <style>
    .menu {
      background-color: #00000050;
      height: 80px;
      width: 100%;
      position: absolute;
      bottom: 0;
      overflow-x: scroll;
      overflow-y: hidden;
      z-index: 2;
      display: flex;
      flex-flow: row;
    }
    .menuItem {
      display: flex;
      height: 100%;
      width: auto;
    }
    .transformer {
      height: 100px;
      width: 100px;
      z-index: 2;
      border-radius: 100%;
      position: absolute;
      top: 5px;
      left: 5px;
      display: flex;

    }
    .person {
      height: 100px;
      width: 100px;
      position: absolute;
      z-index: 2;
      display: flex;
    }
    #imageholder img {
      height: 100px;
      width: 100px;
      position: absolute;
      z-index: 2;
      display: flex;
      top: 0;
      right:0;
    }
  </style>
</head>

<body style='margin : 0px; overflow: hidden;'>

  <a-scene>
    <a-assets>
      <a-asset id="helmetModel" src="models/helmet.gltf"></a-asset>
      <a-asset id="beltModel" src="models/belt.gltf"></a-asset>
      <a-asset id="chestModel" src="models/chest.gltf"></a-asset>
      <a-asset id="chestplateModel" src="models/chestplate.gltf"></a-asset>
      <a-asset id="leftfootModel" src="models/foot_left.gltf"></a-asset>
      <a-asset id="rightfootModel" src="models/foot_right.gltf"></a-asset>
      <a-asset id="leftforearmModel" src="models/forearm_left.gltf"></a-asset>
      <a-asset id="rightforearmModel" src="models/forearm_right.gltf"></a-asset>
      <a-asset id="gunModel" src="models/gun.gltf"></a-asset>
      <a-asset id="leftmedallionModel" src="models/medallion_left.gltf"></a-asset>
      <a-asset id="rightmedallionModel" src="models/medallion_right.gltf"></a-asset>
      <a-asset id="leftshinModel" src="models/shin_left.gltf"></a-asset>
      <a-asset id="rightshinModel" src="models/shin_right.gltf"></a-asset>
      <a-asset id="leftshoulderModel" src="models/shoulder_left.gltf"></a-asset>
      <a-asset id="rightshoulderModel" src="models/shoulder_right.gltf"></a-asset>
      <a-asset id="leftthighModel" src="models/thigh_left.gltf"></a-asset>
      <a-asset id="rightthighModel" src="models/thigh_right.gltf"></a-asset>
      <a-asset id="transformerModel" src="models/transformerModel.gltf"></a-asset>
    </a-assets>

    <div id="menustuff"></div>
    <a-text id="info" style='display:none'></a-text>
    <a-entity id="body" position="-.85 1 0" rotation="0 0 -90"></a-entity>
    <a-entity xr="ar: true; vr: false; magicWindow: false"></a-entity>

  </a-scene>
</body>
<script>
  // code for body tracking remixed for VR from Tensorflow & Posenet https://www.npmjs.com/package/@tensorflow-models/posenet
  //

  var assets = document.querySelector('a-assets')
  var canvas;
  var imageElement;
  var camera;
  var body = document.getElementById('body');

  setTimeout(function(){
      canvas = document.querySelector('.webxr-realities').childNodes[0]
      camera = document.createElement('a-camera');
      camera.setAttribute('collider-check');
      camera.setAttribute('raycaster','objects:.collidable');
      camera.setAttribute('cursor');
      camera.appendChild(body);
      scene.appendChild(camera);
  }, 2000);


  //body tracking with posenet
  async function detectPoseInRealTime(canvas) {
    console.log("running detect pose function")
    const flipHorizontal = false;
    const net = await posenet.load(.5);
    const imageScaleFactor = .2;
    const outputStride = 16;

    async function poseDetectionFrame() {

      let poses = [];
      let minPoseConfidence = 0.2;
      let minPartConfidence = 0.5;

      const pose = await net.estimateSinglePose(
        canvas, imageScaleFactor, flipHorizontal, outputStride);
      poses.push(pose);
      poses.forEach(({
        score,
        keypoints
      }) => {
        if (score >= minPoseConfidence) {
          drawSkeleton(keypoints, minPartConfidence);
        }
      });
      requestAnimationFrame(poseDetectionFrame);
    }
    poseDetectionFrame();
  }
  const modelMapping = {
    nose: "#helmetModel",
    leftEye: "",
    rightEye: "",
    leftEar: "",
    rightEar: "",
    leftShoulder: "#leftshoulderModel",
    rightShoulder: "#rightshoulderModel",
    leftElbow: "#leftforearmModel",
    rightElbow: "#rightforearmModel",
    leftWrist: "",
    rightWrist: "#gunModel",
    leftHip: "#leftthighModel",
    rightHip: "#rightthighModel",
    leftKnee: "#leftshinModel",
    rightKnee: "#rightshinModel",
    leftAnkle: "#leftfootModel",
    rightAnkle: "#rightfootModel"
  };

  const rotationMapping = {
    nose: {
      x: 0,
      y: 180,
      z: -90
    },
    leftShoulder: {
      x: 180,
      y: 0,
      z: 90
    },
    rightShoulder: {
      x: 180,
      y: 0,
      z: 90
    },
    leftElbow: {
      x: 180,
      y: 0,
      z: 90
    },
    rightElbow: {
      x: 180,
      y: 0,
      z: 90
    },
    rightWrist: {
      x: 180,
      y: 0,
      z: 90
    },
    leftHip: {
      x: 180,
      y: 0,
      z: 90
    },
    rightHip: {
      x: 180,
      y: 0,
      z: 90
    },
    leftKnee: {
      x: 180,
      y: 0,
      z: 90
    },
    rightKnee: {
      x: 180,
      y: 0,
      z: 90
    },
    leftAnkle: {
      x: 180,
      y: 0,
      z: 90
    },
    rightAnkle: {
      x: 180,
      y: 0,
      z: 90
    }
  };

  // beltModel
  // chestModel
  // chestplateModel
  // leftmedallionModel
  // rightmedallionModel
  // transformerModel

  const itemList = {
    1: "#helmetModel",
    2: "#beltModel",
    3: "#chestModel",
    4: "#chestplateModel",
    5: "#leftmedallionModel",
    6: "#leftshoulderModel",
    7: "#rightshoulderModel",
    8: "#leftforearmModel",
    9: "#rightforearmModel",
    10: "#rightmedallionModel",
    11: "#gunModel",
    12: "#leftthighModel",
    13: "#rightthighModel",
    14: "#leftshinModel",
    15: "#rightshinModel",
    16: "#leftfootModel",
    17: "#rightfootModel"
  };
  const imageList = {
    1: "helmetModel",
    2: "beltModel",
    3: "chestModel",
    4: "chestplateModel",
    5: "leftmedallionModel",
    6: "leftshoulderModel",
    7: "rightshoulderModel",
    8: "leftforearmModel",
    9: "rightforearmModel",
    10: "rightmedallionModel",
    11: "gunModel",
    12: "leftthighModel",
    13: "rightthighModel",
    14: "leftshinModel",
    15: "rightshinModel",
    16: "leftfootModel",
    17: "rightfootModel"
  };

  var itemMenu;
  var menustuff;
  var transformer;
  var scene = document.querySelector('a-scene');
  var radius = 1;
  var circle;

  //random - random functions remixed from Networked AFrame's spawn-in-cicle component
  function getRandomAngleInRadians() {
    return Math.random() * Math.PI * 2;
  }

  function randomPointOnCircle(radius, angleRad) {
    var x = Math.cos(angleRad) * radius;
    var y = Math.sin(angleRad) * radius;
    return {
      x: x,
      y: y
    };
  }

  //create item list
  function createList() {
    menustuff = document.getElementById('menustuff');
    itemMenu = document.createElement('div');
    itemMenu.setAttribute('class', 'menu');
    for (item in imageList) {
      let piece = document.createElement('img');
      piece.setAttribute('class', 'menuItem');
      piece.setAttribute('onclick', 'spawnModel(' + item + ')')
      piece.setAttribute('src', "imgs/" + imageList[item] + "_img.png");
      itemMenu.appendChild(piece);
    }
    menustuff.appendChild(itemMenu);
    transformer = document.createElement('img');
    transformer.setAttribute('src', 'imgs/transformerModel_img.png')
    transformer.setAttribute('class', 'transformer');
    menustuff.appendChild(transformer);
  }

  // create model - random functions remixed from Networked AFrame's spawn-in-cicle component
  function spawnModel(item) {
    console.log("making a new ", item)
    let model = document.createElement('a-entity');
    model.setAttribute('gltf-model', itemList[item]);

    var center = body.getAttribute('position');
    var angleRad = getRandomAngleInRadians();
    var circlePoint = randomPointOnCircle(radius, angleRad);
    var worldPoint = {
      x: circlePoint.x + center.x,
      y: 0,
      z: circlePoint.y + center.z - 1
    };

    model.setAttribute('position', worldPoint);

    var angleDeg = angleRad * 180 / Math.PI;
    var angleToCenter = -1 * angleDeg - 90;
    var rotationStr = '0 ' + angleToCenter + ' 0';

    model.setAttribute('rotation', rotationStr);
    model.setAttribute('class', 'collidable');
    scene.appendChild(model);
  }

  //creates joints
  function createJoint(part, position) {
    console.log("creating joints")
    var joint = document.createElement('a-entity');
    joint.setAttribute("id", part);
    body.appendChild(joint);
    var getJoint = document.getElementById(part);
    getJoint.setAttribute("gltf-model", modelMapping[part]);
    getJoint.setAttribute("rotation", rotationMapping[part]);
  }

  // updates joint position
  function moveJoint(scale, part, position) {
    document.getElementById(part).setAttribute('position', {
      x: position.y * scale,
      y: position.x * scale,
      z: -1.7
    })
  }

  // Draws pose into VR Scene
  function drawSkeleton(keypoints, minPartConfidence, scale = .0035) {
    console.log("drawing skeleton")
    keypoints.forEach((keypoint) => {
      if (keypoint.score >= minPartConfidence) {
        if (document.getElementById(keypoint.part)) {
          moveJoint(scale, keypoint.part, keypoint.position)
        } else {
          createJoint(keypoint.part, keypoint.position);
        }
      }
      return
    })
  }

  async function bindPage() {
    createList()
    setTimeout(function(){
      console.log('image', canvas)
      detectPoseInRealTime(canvas);
    }, 2000);
  }

  bindPage();

</script>

</html>
